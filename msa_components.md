# Способы повышения отказоустойчиваости в микросервисной архитектуре

1. Статья:
    1. описывает взаимодействия между различными компонентами микросервисной архитектуры;
    0. предлагает решения синхронной и ассинхронной обоработки событий;
    0. рассматривает неудовлетворительные и приемлимые решения.



# Оглавление

1. [Cинтаксис](#cинтаксис)
0. [Виды взаимодействия](#виды-взаимодействия)
0. [Примеры решений](#примеры-решений)



# Cинтаксис

1. Ниже используется [синтаксис описания взаимодействия МСА](msa_sintax.md)



# Виды взаимодействия

1. Виды взаимодействия компонентов классифицированы как:
    1. [Удовлетворительные взаимодействия](#удовлетворительные-взаимодействия)
    0. [Неудовлетворительное взаимодействиеы](#неудовлетворительные-взаимодействия)



## Удовлетворительные взаимодействия

1. Перечислены взаимодействия, рекомендуемые к использованию в микросервисной архитектуре в произвольной комбинации.
    1. ```T[ w(Q) ]``` - один поток пишет в одну очередь;
    0. ```T*[ w(Q) ]``` - множество потоков пишут в одну очередь;
    0. ```T[ r(Q) ]``` - один поток читает из очереди;
    0. ```T*[ R(Q) ]``` - множетство потоков читают из одной очерди, при этом у каждого свой офсет;
    0. ```T[ r(S*) ]``` - один поток читает множество состояний.



## Неудовлетворительные взаимодействия

1. Перечислены взаимодействия, не рекомендуемые к использованию из за потенциальных проблем при реализации.
    1. ```T[ r(Q*) ]``` - один поток читает из нескольких очередй (прблема синхронизации);
    0. ```T[ w(S*) ]``` - один поток изменяет множество состояний (проблема целостности транзакции).



# Примеры решений

1. Предлагаются следующие примеры решений:
    1. [Регистрация события](#Регистрация-события)
    0. [Обработка события](#Обработка-события)
    0. [Обработка событий из двух источников](#Обработка-событий-из-двух-источников)
    0. [Гарантированная последовательная обработка](#Гарантированная-последовательная-обработка)
    0. [Паралельная обработка события](#Паралельная-обработка-события)
    0. [Паралельная обработка с общим результатом](#Паралельная-обработка-с-общим-результатом)



## Регистрация события

1. Поток получает данные и размещает их в очередь.



### Удовлетворительное решение

```
> T0[ w( Q1 ) ]
```
1. Поток T0 пишет в очередь Q1.
0. Очередь Q1 решает вопрос быстрого отклика после вызова потока T0 и последующей гарантированной обработки.



## Обработка события

1. Очередь содержит события, которые необходимо обрабоать и сохранить состояние обработки.



### Удовлетворительное решение

```
   > Q0
      \
T1[ r( Q0 ) - w( S1 ) = c( Q0 )]
```
1. Очередь Q0 содержит события.
0. Поток T1 
    1. читает из очереди Q0
        1. при успехе сохраняет результат работы в состояния S1.
            1. при успехе выполняет коммит сообщения в Q0.



## Обработка событий из двух источников

1. Два различных источника пишут сообщения в одну очередь, которая должна быть разобрана и результаты разбора сохранены.



### Удовлетворительное решение

1. Потоки T1 и T2 пишет в очередь Q1.
0. Очередь Q1 решает вопрос скорейшей гарантированной обработки вызова потока T1 и T2.
0. Поток T3 читает из очереди Q1.
0. Потоки T3 направляют результаты в состояение S1.

```
> T1[ w( Q1 ) ]
          \
   T3[ r( Q1 ) - w( S1 ) = c( Q1 ) ]
          /   
> T2[ w( Q1 ) ]
```



## Гарантированная последовательная обработка

1. Очередь содержит сообщения, каждое должно быть обработано последовательно двумя способами с сохранением состояний, 
при этом результат первого состояния должен быть использован во втором состоянии.



### Неудовлетворительное решение

1. Очередь Q0 содержит перечень задач.
0. Поток T1 получает задачу из Q0.
    0. При успехе поток T1 записывает состояния S1, которое возвращает результат для состоянии S2.
        0. При успехе поток T1 записывает в состояние S2 результат записи в S1. 
            0. При успехе поток T1 выполняет коммит очереди Q0. 
0. Проблема заключается в потенциальном отказе в точке *#*, при этом состояние S1 необратимо изменено а состояние S2 не изменено.

```
    > Q0
       \
T1[ r( Q0 ) - w( S1 ) # w( S2 ) = c( Q0 ) ]
```



### Удовлетворительное решение

1. Очередь Q1 содержит перечень задач.

```
T1[ r( Q1 ) - w( S1 ) = w( Q2 ) = c( Q1 ) ]
                            \
                      T2[ r( Q2 ) - w( S2 ) = c( Q2 ) ]
```


### Гарантированное решение

1. Очередь Q1 содержит перечень задач.

```                    
T1[ r( Q1 ) - r( S1 ) - w( S1 ) - { w( Q2 ) - c( Q1 ) }]
                                        \
                                  T2[ r( Q2 ) - r( S2 ) - w( S2 ) - c( Q2 ) ]
```



## Паралельная обработка события

1. Очередь содержит события при этом каждое событие должно быть обработано двумя независимыми обработчиками, 
и результат обработки каждого следует сохранить как состояния.



### Не удовлетворительное решение

1. Действия:
    1. Очередь Q0 содержит сообщения.
    0. Поток T1
        1. читает из очереди Q0
            1. при успехе сохраняет состояние S1
                1. при успехе выполняет коммит задачи в Q0.
    0. Поток T2
        1. читает из очереди Q0
            1. при успехе сохраняет состояние S2
                1. при успехе выполняет коммит задачи в Q0.
0. Проблема:
    1. Исполнение основано на разборе одной очереди Q0.
    0. При невозможности исполнения одним из потоков необходимо:
         1. повторное отложенное исполнение задачи посредством другой очереди или
         0. остановка обработки очереди до устранения причин проблемы.

```
T1[ r( Q0 ) - w( S1 ) = c( Q0 )]
      /                   
   > Q0
      \                   
T2[ r( Q0 ) - w( S2 ) = c( Q0 )]
```


### Удовлетворительное решение

1. Очередь Q0 содержит события.
0. Поток T0:
    1. ставит задачу в очередь Q1
    0. ставит задачу в очередь Q2
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе сохраняет состояние S1
            1. при успехе выполняет коммит задачи в Q1.
            0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе выполняет коммит задачи в Q2.
            0. при провале выполняет сдвиг задачи в Q2
```
   > Q0
      \
T0[ r( Q0 ) - w( Q1 ) = w( Q2 ) = c( Q0 )]
                  \         \
                   \  T2[ r( Q2 ) - w( S2 ) = c( Q2 )]
                    \
              T2[ r( Q1 ) - w( S1 ) = c( Q1 )]
```



### Гарантированное решение

```
   > Q0
      \
T0[ r( Q0 ) - { w( Q1 ) - w( Q2 ) - c( Q0 )}]
                  \         \
                   \  T2[ r( Q2 ) - w( S2 ) = c( Q2 )]
                    \
              T2[ r( Q1 ) - w( S1 ) = c( Q1 )]
```

1. Очередь Q0 содержит события.
0. Поток T0 в транзакции:
    1. ставит задачу в очередь Q1
    0. ставит задачу в очередь Q2
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе читает сохраняет состояние S1
            1. при отсутствии S1 сохраняет состояние S1
                1. при успехе выполняет коммит задачи в Q1.
                0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе читает сохраняет состояние S2
            1. при успехе сохраняет состояние S2
                1. при успехе выполняет коммит задачи в Q2.
                0. при провале выполняет сдвиг задачи в Q2



## Паралельная обработка с общим результатом

1. Очередь содержит сообщения, необходим паралельный запуск обработки сообщения с выдачей итогового результата при исполнениии всех обработок.



### Удовлетворительное решение

1. Очередь Q0 содержит события.
0. Поток T0:
    1. ставит задачу в очередь Q1 для состояния S1
    0. ставит задачу в очередь Q2 для состояния S2
    0. ставит задачу в очередь Q3 для итоговой синхронизации
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе сохраняет состояние S1
            1. при успехе выполняет коммит задачи в Q1.
            0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе выполняет коммит задачи в Q2.
            0. при провале выполняет сдвиг задачи в Q2
0. Поток T3:
    1. читает сообщения из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе
                1. читает состояние S1
                0. читает состояние S2
                0. при их наличии пишет состояние S3
                    1. при успехе выполняет комит задачи Q3
                    0. при провале выполняет сдвиг задачи в Q3
                0. при провале выполняет сдвиг задачи в Q3

```
    > Q0
       \                              
T0[ r( Q0 ) - w( Q1 ) = w( Q2 ) = w( Q3 ) = c( Q0 )]
                  \         \         \  
                   \         \  T3[ r( Q3 ) - r( S1 ) - r( S2 ) - w( S3 ) = c( Q3 ) ]
                    \         \
                     \  T2[ r( Q2 ) - w( S2 ) = c( Q2 ) ]
                      \
                T2[ r( Q1 ) - w( S1 ) = c( Q1 ) ]
```


### Гарантированное решение

1. Очередь Q0 содержит события.
0. Поток T0 в транзакции:
    1. ставит задачу в очередь Q1 для состояния S1
    0. ставит задачу в очередь Q2 для состояния S2
    0. ставит задачу в очередь Q3 для итоговой синхронизации
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе читает состояние S1
            1. при отсутсвии ранее сохраненного состояния S1:
                1. сохраняет состояние S1
                    1. при успехе выполняет коммит задачи в Q1.
                    0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе читает состояние S2
            1. при отсутсвии ранее сохраненного состояния S2:
                1. сохраняет состояние S2
                    1. при успехе выполняет коммит задачи в Q2.
                    0. при провале выполняет сдвиг задачи в Q2
0. Поток T3:
    1. читает сообщениу из очереди Q3
        1. при успехе читает состояние S1
            1. при успехе читает состояние S2
                1. при успехе читает состояние S3
                    1. при отсутствии записи состояния S3
                        1. выполняет запись состояния S3
                            1. при успехе выполняет комит задачи Q3
                            0. при провале выполняет сдвиг задачи в Q3

```
    > Q0
       \                              
T0[ r( Q0 ) - { w( Q1 ) - w( Q2 ) - w( Q3 ) - c( Q0 )}]
                  \         \         \  
                   \         \  T3[ r( Q3 ) - r( S1 ) - r( S2 ) - r( S3 ) - w( S3 ) - c( Q3 ) ]
                    \         \
                     \  T2[ r( Q2 ) - r( s2 ) - w( S2 ) - c( Q2 ) ]
                      \
                T2[ r( Q1 ) - r( S1 ) - w( S1 ) - c( Q1 ) ]
```
