# Анализ отказоустойчивости решенией для МСА

1. Статья:
    1. описывает взаимодействия между различными компонентами микросервисной архитектуры;
    0. предлагает решения синхронной и ассинхронной обоработки событий;
    0. рассматривает неудовлетворительные решения.


# Оглавление

1. [Cинтаксис](#cинтаксис)
0. [Виды взаимодействия](#виды-взаимодействия)
0. [Примеры решений](#примеры-решений)


# Cинтаксис

1. Рассматриваем следующие компоненты:
    1. ```T``` - (Thread) поток сервиса, микросервиса или монолита;
    0. ```S``` - (State) изменение состояния некой системы, любая внешнаяя система рассматривается как хранилище состояний;
    0. ```Q``` - (Queue) топик очереди;
0. При взаимодейсвтии компонентов используюется следюущие обозначения:
    1. ```*``` - множество указанных компонентов (более одного);
    0. ```[]``` - последовательное исполнение действий в одном потоке без гарантии транзакционной целостности, с применением следующих разделителей:
        1. ```-``` - последовательное действие в потоке не критичное к прерыванию;
        0. ```=``` - последовательное действие в потоке критичноее к прерыванию, но неизбежное;
        0. ```#``` - последовательное действие в потоке критичноее к прерыванию.
    0. ```{}``` - последовательное транзакционно целостное исполнение действий в одном потоке.
    0. ```w``` - (write) операция записи;
    0. ```r``` - (read) операция чтения;
    0. ```c``` - (commit) операция подтверждения для очереди, разновидность чтения.
    0. ```\``` ```/``` - хронология использования компонентов;
    0. ```>``` - источник поступления первичных данных.



# Виды взаимодействия

1. Указанные компоненты классифицированы как:
    1. [Удовлетворительное взаимодействиеы](#удовлетворительные-взаимодействия)
    0. [Неудовлетворительное взаимодействиеы](#неудовлетворительные-взаимодействия)



## Удовлетворительные взаимодействия

1. Перечислены структуры, рекомендуемые к использованию в МСА и допустима их проихзвольня комбинация.
    1. ```T[ w(Q) ]``` - один поток пишет в одну очередь;
    0. ```T*[ w(Q) ]``` - множество потоков пишут в одну очередь;
    0. ```T[ r(Q) ]``` - один поток читает из очереди;
    0. ```T*[ R(Q) ]``` - множетство потоков читают из одной очерди, при этом у каждого свой офсет;
    0. ```T[ r(S*) ]``` - один поток читает множество состояний.



## Неудовлетворительные взаимодействия

1. Перечислены структуры, не рекомендуемые к использованию из за возникающих проблем.
    1. ```T[ r(Q*) ]``` - один поток читает из нескольких очередй (прблема синхронизации);
    0. ```T[ w(S*) ]``` - один поток изменяет множество состояний (проблема целостности транзакции).



# Примеры решений


## Регистрация события

1. Поток получает данные и размещает их в очередь.

### Удовлетворительное решение

```
   > T0[ w( Q1 ) ]
```
1. Поток T0 пишет в очередь Q1.
0. Очередь Q1 решает вопрос быстрого отклика после вызова потока T0 и последующей гарантированной обработки.



## Обработка события

1. Очередь содержит события, которые необходимо обрабоать и сохранить состояние обработки.

### Удовлетворительное решение

```
       > Q0
          \
   T1[ r( Q0 ) - w( S1 ) = c( Q0 )]
```
1. Очередь Q0 содержит события.
0. Поток T1 
    1. читает из очереди Q0
        1. при успехе сохраняет результат работы в состояния S1.
            1. при успехе выполняет коммит сообщения в Q0.



## Обработка событий из двух источников

1. Два различных источника пишут сообщения в одну очередь, которая должна быть разобрана и результаты разбора сохранены.

### Удовлетворительное решение

1. Потоки T1 и T2 пишет в очередь Q1.
0. Очередь Q1 решает вопрос скорейшей гарантированной обработки вызова потока T1 и T2.
0. Поток T3 читает из очереди Q1.
0. Потоки T3 направляют результаты в состояение S1.

```
    > T1[ w( Q1 ) ]
              \
       T3[ r( Q1 ) - w( S1 ) = c( Q1 ) ]
              /   
    > T2[ w( Q1 ) ]
```



## Гарантированная последовательная обработка

1. Очередь содержит сообщения, каждое должно быть обработано последовательно двумя способами с сохранением состояний, 
при этом результат первого состояния должен быть использован во втором состоянии.

### Неудовлетворительное решение

1. Очередь Q0 содержит перечень задач.
0. Поток T1 получает задачу из Q0.
    0. При успехе поток T1 записывает состояния S1, которое возвращает результат для состоянии S2.
        0. При успехе поток T1 записывает в состояние S2 результат записи в S1. 
            0. При успехе поток T1 выполняет коммит очереди Q0. 
0. Проблема заключается в потенциальном отказе в точке *#*, при этом состояние S1 необратимо изменено а состояние S2 не изменено.

```
    > Q0
       \
T1[ r( Q0 ) - w( S1 ) # w( S2 ) = c( Q0 ) ]
```

### Удовлетворительное решение

1. Очередь Q1 содержит перечень задач.
0. T2 ставит в очередь Q3 задачу.
0. T3 конкурентно с T4 выполняют разбор очереди Q3.
0. T3 выполняет работу и размещает результаты в состоянии S1.
0. T4 выполняет чтение из состояния S1 для получения результата работ T3.
    1. при отсутсвии результаат задача переносится в Q3
    0. при наличии результата 

```
T1[ r( Q1 ) - w( S1 ) = w( Q2 ) = c( Q1 ) ]
                            \
                     T2[ r( Q2 ) - w( S2 ) = c( Q2 ) ]
```



## Паралельная обработка события

1. Очередь содержит события при этом каждое событие должно быть обработано двумя независимыми обработчиками, 
и результат обработки каждого следует сохранить как состояния.

### Не удовлетворительное решение

```
   T1[ r( Q0 ) - w( S1 ) = c( Q0 )]
          /                   
       > Q0
          \                   
   T2[ r( Q0 ) - w( S2 ) = c( Q0 )]
```

1. Действия:
    1. Очередь Q0 содержит сообщения.
    0. Поток T1
        1. читает из очереди Q0
            1. при успехе сохраняет состояние S1
                1. при успехе выполняет коммит задачи в Q0.
    0. Поток T2
        1. читает из очереди Q0
            1. при успехе сохраняет состояние S2
                1. при успехе выполняет коммит задачи в Q0.
0. Проблема:
    1. Исполнение основано на разборе одной очереди Q0.
    0. При невозможности исполнения одним из потоков необходимо:
         1. повторное отложенное исполнение задачи посредством другой очереди или
         0. остановка обработки очереди до устранения причин проблемы.



### Удовлетворительное решение

```
        > Q0
           \
    T0[ r( Q0 ) - w( Q1 ) = w( Q2 ) = c( Q0 )]
                      \         \
                       \  T2[ r( Q2 ) - w( S2 ) = c( Q2 )]
                        \
                 T2[ r( Q1 ) - w( S1 ) = c( Q1 )]
```

1. Очередь Q0 содержит события.
0. Поток T0 в транзакции:
    1. ставит задачу в очередь Q1
    0. ставит задачу в очередь Q2
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе сохраняет состояние S1
            1. при успехе выполняет коммит задачи в Q1.
            0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе выполняет коммит задачи в Q2.
            0. при провале выполняет сдвиг задачи в Q2




## Паралельное исполнение задач с общим синхронным результатом

1. Очередь содержит сообщения, необходим паралельный запуск обработки сообщения с выдачей итогового результата при исполнениии всех обработок.

### Удовлетворительное решение

1. Очередь Q0 содержит события.
0. Поток T0:
    1. ставит задачу в очередь Q1 для состояния S1
    0. ставит задачу в очередь Q2 для состояния S2
    0. ставит задачу в очередь Q2 для итоговой синхронизации
    0. выполнянет коммит очередь Q0
0. Поток T1:
    1. читает из очереди Q1
        1. при успехе сохраняет состояние S1
            1. при успехе выполняет коммит задачи в Q1.
            0. при провале выполняет сдвиг задачи в Q1
0. Поток T2:
    1. читает из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе выполняет коммит задачи в Q2.
            0. при провале выполняет сдвиг задачи в Q2
0. Поток T3:
    1. читает сообщения из очереди Q2
        1. при успехе сохраняет состояние S2
            1. при успехе
                1. читает состояние S1
                0. читает состояние S2
                0. при их наличии пишет состояние S3
                    1. при успехе выполняет комит задачи Q3
                    0. при провале выполняет сдвиг задачи в Q3
                0. при провале выполняет сдвиг задачи в Q3

```
        > Q0
           \                              
    T0[ r( Q0 ) - w( Q1 ) = w( Q2 ) = w( Q3 ) = c( Q0 )]
                      \         \         \  
                       \         \  T3[ r( Q3 ) - r( S1 ) - r( s2 ) - w( s3 ) = c( Q3 ) ]
                        \         \
                         \  T2[ r( Q2 ) - w( S2 ) = c( Q2 ) ]
                          \
                   T2[ r( Q1 ) - w( S1 ) = c( Q1 ) ]
```
