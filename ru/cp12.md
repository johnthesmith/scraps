1. CP-12 (Composite Predicates) — система из 12 композитных предикативных 
операторов для сопоставления множеств кортежей.
0. Каждый оператор описывает правила логического соответствия между кортежами 
ключа и кортежами замка на основе операций: равенство, включённость, 
пересечение, в сочетаниях все/хотя бы один.

0. `CP-12` опирается на принципы декларативной логики, теории множеств.


## Дано

1. Даны произвольные кортежи вида:
    1. Ключ: `[[a, b], [c, d]]`
    0. Замок: `[[a, b], [c, d], [e,f]]`



# Задача

1. Необходимо определить предикативный результат отношения кортежей ключа к 
кортежам замка с помощью минимального набора операторов сопоставления для 
различных ситуаций.
0. Порядок кортежей и порядок атрибутов в кортежах значения не имеют.



# Решение

1. Определяю 12 композитных операторов сопоставления кортежей ключ-замок, 
основанных на трёх типах отношений (равенство, включённость, пересечение) и двух 
кванторах (∀ для всех / ∃ для хотя бы одного).



## Операторы

1. Для выбора операторов применяется общая логика трех уровней:
    1. Первый уровень — как обрабатывать все кортежи ключа:
        1. `AND` — условие должно выполняться для **всех** кортежей ключа;
        0. `OR` — достаточно выполнения хотя бы для **одного** кортежа ключа.
    2. Второй уровень — как сравнивать каждый кортеж замка:
        1. `AND` — условие должно выполняться для **всех** кортежей замка; 
        0. `OR` — достаточно выполнения хотя бы для **одного** кортежа замка.
    3. Третий уровень — тип сопоставления между кортежами:
        0. `EQUALS` — кортежи полностью равны;
        0. `CONTAINS` — кортеж ключа содержится в кортежe замка;
        0. `INTERSECTS` — кортежи имеют хотя бы один общий атрибут.
0. Итоговое имя операра формируется путем комбинации всех перечисленных значений для трех уровней.
0. Следующая таблица содержит `CP-12`:

| №  | Имя оператора        | SQL-нотация                   | Пояснение                                                        | Формальное описание                         |
|----|----------------------|-------------------------------|------------------------------------------------------------------|---------------------------------------------|
| 1  | AND_AND_EQUALS       | FULL_OUTER_JOIN_EQUALS        | Все кортежи ключа равны всем кортежам записи                     | ∀k∈K ∃c∈C: k = c ∧ ∀c∈C ∃k∈K: k = c         |
| 2  | AND_OR_EQUALS        | LEFT_JOIN_EQUALS              | Каждый кортеж ключа равен хотя бы одному кортежу записи          | ∀k∈K ∃c∈C: k = c                            |
| 3  | OR_AND_EQUALS        | RIGHT_JOIN_EQUALS             | Хотя бы один кортеж ключа равен всем кортежам записи             | ∃k∈K ∀c∈C: k = c                            |
| 4  | OR_OR_EQUALS         | SEMI_JOIN_EQUALS              | Хотя бы один кортеж ключа равен хотя бы одному кортежу записи    | ∃k∈K ∃c∈C: k = c                            |
| 5  | AND_AND_CONTAINS     | FULL_OUTER_JOIN_CONTAINS      | Все кортежи ключа содержатся во всех кортежах записи             | ∀k∈K ∃c∈C: k ⊆ c ∧ ∀c∈C ∃k∈K: k ⊆ c         |
| 6  | AND_OR_CONTAINS      | LEFT_JOIN_CONTAINS            | Каждый кортеж ключа содержится хотя бы в одном кортежe записи    | ∀k∈K ∃c∈C: k ⊆ c                            |
| 7  | OR_AND_CONTAINS      | RIGHT_JOIN_CONTAINS           | Хотя бы один кортеж ключа содержится во всех кортежах записи     | ∃k∈K ∀c∈C: k ⊆ c                            |
| 8  | OR_OR_CONTAINS       | SEMI_JOIN_CONTAINS            | Хотя бы один кортеж ключа содержится хотя бы в одном записи      | ∃k∈K ∃c∈C: k ⊆ c                            |
| 9  | AND_AND_INTERSECTS   | CROSS_JOIN_INTERSECTS         | Каждый кортеж ключа пересекается с каждым кортежем записи        | ∀k∈K ∀c∈C: k ∩ c ≠ ∅                        |
| 10 | AND_OR_INTERSECTS    | LEFT_JOIN_INTERSECTS          | Каждый кортеж ключа пересекается хотя бы с одним кортежем записи | ∀k∈K ∃c∈C: k ∩ c ≠ ∅                        |
| 11 | OR_AND_INTERSECTS    | RIGHT_JOIN_INTERSECTS         | Один кортеж ключа пересекается с каждым кортежем записи          | ∃k∈K ∀c∈C: k ∩ c ≠ ∅                        |
| 12 | OR_OR_INTERSECTS     | SEMI_JOIN_INTERSECTS          | Один кортеж ключа пересекается хотя бы с одним кортежем записи   | ∃k∈K ∃c∈C: k ∩ c ≠ ∅                        |


## Дополнительно

1. Указанный принцип может быть расширен до `CP-24` путём добавления отрицания 
   (`NOT`) к каждому из 12 операторов.
0. Таким образом, формируется полный набор: 
    1. 12 положительных правил;
    0. 12 отрицательных (NOT_...).
0. Это даёт возможность использовать исключения и запреты на соответствие.



# Примеры

## AND_AND_EQUALS

**Пояснение:** Все кортежи ключа равны всем кортежам записи.

### ✅ Положительный пример:
- Ключ: `[[молоко], [спать]]`
- Замок: `[[молоко], [спать]]`
- Объяснение: Все привычки хозяина есть у каждого кота.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [спать]]`
- Замок: `[[молоко], [игра]]`
- Объяснение: У кота вместо «спать» — «игра», нет полного совпадения.

---

## AND_OR_EQUALS

**Пояснение:** Каждый кортеж ключа равен хотя бы одному кортежу записи.

### ✅ Положительный пример:
- Ключ: `[[молоко], [спать]]`
- Замок: `[[молоко], [игра], [спать]]`
- Объяснение: У кота есть и молоко, и спать, среди прочих.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [сон]]`
- Замок: `[[молоко], [игра]]`
- Объяснение: Ключ требует «сон», которого у кота нет.

---

## OR_AND_EQUALS

**Пояснение:** Хотя бы один кортеж ключа равен всем кортежам записи.

### ✅ Положительный пример:
- Ключ: `[[спать], [молоко]]`
- Замок: `[[спать], [спать]]`
- Объяснение: Есть привычка «спать», совпадающая со всеми в записи.

### ❌ Отрицательный пример:
- Ключ: `[[спать], [молоко]]`
- Замок: `[[спать], [игра]]`
- Объяснение: Нет одного ключевого кортежа, совпадающего со всеми.

---

## OR_OR_EQUALS

**Пояснение:** Хотя бы один кортеж ключа равен хотя бы одному кортежу записи.

### ✅ Положительный пример:
- Ключ: `[[спать], [лазить]]`
- Замок: `[[игра], [спать]]`
- Объяснение: Оба имеют «спать».

### ❌ Отрицательный пример:
- Ключ: `[[сон], [лазить]]`
- Замок: `[[мяу], [игра]]`
- Объяснение: Никаких совпадений.

---

## AND_AND_CONTAINS

**Пояснение:** Все кортежи ключа содержатся в каждом кортеже записи.

### ✅ Положительный пример:
- Ключ: `[[молоко]]`
- Замок: `[[молоко, спать], [молоко, игра]]`
- Объяснение: «молоко» есть в каждой привычке кота.

### ❌ Отрицательный пример:
- Ключ: `[[молоко]]`
- Замок: `[[молоко, спать], [игра]]`
- Объяснение: Второй кортеж не содержит «молоко».

---

## AND_OR_CONTAINS

**Пояснение:** Каждый кортеж ключа содержится хотя бы в одном кортеже записи.

### ✅ Положительный пример:
- Ключ: `[[молоко], [игра]]`
- Замок: `[[молоко, спать], [игра, сон]]`
- Объяснение: Оба требования покрыты.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [сон]]`
- Замок: `[[молоко, спать], [игра]]`
- Объяснение: «сон» не найден нигде.

---

## OR_AND_CONTAINS

**Пояснение:** Хотя бы один кортеж ключа содержится во всех кортежах записи.

### ✅ Положительный пример:
- Ключ: `[[молоко]]`
- Замок: `[[молоко, игра], [молоко, спать]]`
- Объяснение: «молоко» есть в каждом.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [сон]]`
- Замок: `[[молоко, игра], [игра, спать]]`
- Объяснение: Ни один ключевой кортеж не входит во все записи.

---

## OR_OR_CONTAINS

**Пояснение:** Хотя бы один кортеж ключа содержится хотя бы в одном кортеже записи.

### ✅ Положительный пример:
- Ключ: `[[молоко]]`
- Замок: `[[игра, сон], [молоко, спать]]`
- Объяснение: Один кортеж содержит «молоко».

### ❌ Отрицательный пример:
- Ключ: `[[сон]]`
- Замок: `[[игра], [молоко]]`
- Объяснение: Нет попаданий.

---

## AND_AND_INTERSECTS

**Пояснение:** Все кортежи ключа пересекаются со всеми кортежами записи.

### ✅ Положительный пример:
- Ключ: `[[молоко, игра], [спать]]`
- Замок: `[[молоко, спать], [игра, спать]]`
- Объяснение: Все имеют общие элементы.

### ❌ Отрицательный пример:
- Ключ: `[[молоко, игра], [сон]]`
- Замок: `[[молоко, спать], [игра, мяу]]`
- Объяснение: «сон» не пересекается.

---

## AND_OR_INTERSECTS

**Пояснение:** Каждый кортеж ключа пересекается хотя бы с одним кортежем записи.

### ✅ Положительный пример:
- Ключ: `[[молоко], [сон]]`
- Замок: `[[молоко, спать], [игра, сон]]`
- Объяснение: Всё покрыто.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [сон]]`
- Замок: `[[молоко, спать], [игра, мяу]]`
- Объяснение: «сон» не пересекается ни с чем.

---

## OR_AND_INTERSECTS

**Пояснение:** Хотя бы один кортеж ключа пересекается со всеми кортежами записи.

### ✅ Положительный пример:
- Ключ: `[[молоко, сон], [спать]]`
- Замок: `[[сон, игра], [молоко, сон]]`
- Объяснение: «молоко, сон» пересекается со всеми.

### ❌ Отрицательный пример:
- Ключ: `[[молоко], [игра]]`
- Замок: `[[молоко], [мяу]]`
- Объяснение: Ни один не покрывает всё.

---

## OR_OR_INTERSECTS

**Пояснение:** Хотя бы один кортеж ключа пересекается хотя бы с одним кортежем записи.

### ✅ Положительный пример:
- Ключ: `[[молоко], [спать]]`
- Замок: `[[игра], [спать, мяу]]`
- Объяснение: Есть пересечение по «спать».

### ❌ Отрицательный пример:
- Ключ: `[[молоко]]`
- Замок: `[[игра], [сон]]`
- Объяснение: Нет ни одного совпадения.
