# Архитектура сущностей

1. Понятие [сущности](./glossary/Сущности.md) - средство описания объектов, 
явлений и понятий реального мира. Сущность следует рассматривать как абстрактный 
элемент, для описания свойств.



# Оглавление
1. [Авторы](#авторы)
0. [Теория](#теория)
0. [Практика](#практика)
0. [Организация-хранения-сущностей](#организация-хранения-сущностей)
0. [Методы взаимодействия с сущностью](#Методы-взаимодействия-с-сущностью)



# Авторы

1. https://github.com/johnthesmith/
2. https://github.com/igptx



# Теория

1. Для сущности неоходимо минимально определить:
    1. факт существования;
    0. типа сущности. 
0. Все иные описания и свойства сущности следует признать вторичными.
0. Так же следует определить операции с сущностью:
    1. [Создание сущности](#define)
    0. [Проверка существования](#exists)
    0. [Удаление сущности](#delete)



# Практика

1. Для хранения созданных сущностей потребуется отношение кортежей со следующими 
атрибутами:
    1. id - идентификатор сущности;
    0. type - идентификатор типа сущности ( который в свою очередь является сущностью ).
2. Так как [условлена](#теория) невозможность определения сущности без типа,
следует определить первую корневую самотипизирующуюся сущность:
```
[
    {
        "id":"entity",
        "type":"entity"
    }
]
```

> ⚠️ **Важно!** Определение кортежа фактически создает новый домен, развиваемый 
> добавлением сущностей и описанием их свойств.

```
[
    { "id":"animal",    "type":"entity" },
    { "id":"cat",       "type":"animal" },
    { "id":"human",     "type":"animal" }   
]
```


> ℹ️ **Информация** Дальнейшие разделы являются исключительно одной из возможных 
> реализаций.



# Организация хранения сущностей

1. Хранение и обработу сущностей можно осуществлять различными методами:
    1. Хранилище ключ:значение - для простых реализаций с незначительным 
    количеством сущностей;
    0. [Реляционные БД](#Хранилище-сущностей-на-реляционнй-БД) - предпочтительно 
    для существенных объемов сущностей.



## Хранилище сущностей на реляционнй БД

1. В базовом варианте для хранения сущностей следует определить два [отношения](https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_(%D1%80%D0%B5%D0%BB%D1%8F%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C)):
    1. [entity](#отношение-entity) - сущности;
    0. [rid](#отношение-rid) - читаемые идентификаторы.



### Отношение entity

1. Отношение хранит перечень всех сущностей и типизирует их.
0. Содержит следующие атрибуты:
    1. char[32] id - уникальный идентификатор сущности, выбор способа создания 
    идентфикатора рассматривается [отдельно]().
    0. char[32] type_id - идентификатор типа сущности, ссылается на id.
0. Предпочтение отдается операциям insert.
0. Допустима операция update, выполняющая запись в атрибут type_id значения null 
для логического удаления сущности.
0. Отношение предполагает существенную мощность.

### Отношение rid

1. Отношение хранит читаемый идентификатор сущностей.
0. Содержит следующие атрибуты:
    1. char[32] entity_id - идентициатор сущности из отношения entity.
    0. string rid - текстовое представление читаемого идентификатора сущности.
0. Предпочтение отдается операциям insert, отношение не предполагает update и delete.
0. Отношение предполагает сравнительно не большую мощность по сравнению с entity, так как 
количество читаемых идентификаторов обычно ограничинно. 

### Краткая диаграмма отношений

1. Следующая диаграмма представляет выше описанные отношения.

```mermaid
classDiagram 
    direction RL

    class rid {
        char[32] entity_id
        string rid
    }

    class entity {
        char[32] id
        char[32] type_id
    }


    entity --> entity : entity_id → id
    rid --> entity : entity_id → id
```


### Расширенная диаграмма отношений

1. Указанную краткую диаграмму допустимо расширить дополнительными отношениями
для описания связей между сущностями и контекстным описанием свойств сущностей.

```mermaid
graph RL
  subgraph entity ["entity"]
    entity_id["id : char[32]"]
    entity_type_id["type_id : char[32]"]
  end

  subgraph rid ["rid"]
    rid_entity_id["entity_id : char[32]"]
    rid_value["rid : string"]
  end

  rid_entity_id --> entity_id : "entity_id → id"```


# Методы взаимодействия с сущностью

1. Реализцаяи предполагает следующие методы:
    1. [define](#define) - определение сущности;
    2. [check](#check) - проверка существования сущности;
    3. [kill](#kill) - удаление сущности.
2. Указанные методы опционально могут использовать [многомерное представление].



## define

1. Метод define устанавливает (типизирует сщность).
2. В случае 
    1. если сущность отсутствовала, она определяется.
    0. если сущность существовала
        1. и при этом обладала тем же типом, возвращается положительный результат.
        2. и при этом с иным типом, возвращается сообщение об ошибке.

### aргументы define

1. Метод define принимает следующие аргументы:
    1. ```string id``` - Идентификатор сущности;
    2. ```string itType``` - идентификатор типа сущности;
    3. ```array string dim[]``` - массив измерений.

### результат define

1. Метод define возвращает структуру состояний результата.

### алгоритм define

```
json define
(
    /* Идентификтаор типа сущности */
    string ridType, 
    /* Опциональный идентификатор сущности */
    string rid = null, 
    /* Опциональные измерения */
    array string dim[] 
)
{
    switch( algorithm )
    {
        AUTOINCREMENT:
        {
            /*
                Механизм идентификации на основе автоинкремента 
            */
            /* Получаем очередной автоинкрементный индекс */
            id = max( id ) + 1;
            /* Получаем иднетификатор типа если он существует */
            idType = rid 
            -> select({ caption == ridType }) 
            -> get( "endity_id" );
        }
        HASH:
        {
            /*
                Механизм идентификации на основе hash
            */
            /* Вычисляем hash для идентификатора сущности */
            id = hash( rid == null ? getId() : rid );
            /* Вычисляем hash для типа сущности */
            idType = hash( ridType );
            if( !entity -> exists( idType ))
            {
                idType = null;
            }
        }
    }

    if( idType != null )
    {
        /* Проверяем наличие rid для его опциональной регистрации ... */
        if( rid != null && rid -> exists( rid ))
        {
            /* ... и если rid не обнаружен регистрируем его  */
            rid -> insert( "entity_id":id, "rid":rid );
        }

        /* Создаем сущность с идентфикатором id */
        entity -> insert( "id":id, "type_id":idType );

        /* Возвращаем положительный результат с новым идентификатором сущности */
        result = { "code":"ok", "id":id };
    }
    else
    {
        if( rid == ridType )
        {
            /* Регистрируем новый домен */
            rid -> insert( "entity_id":id, "rid":rid );
            entity -> insert( "id":id, "type_id":id );            
            result = { "code":"ok", "id":id };
        }
        else
        {
            /* Информируем пользователя об отсутсвии сущности */
            result = { "code":"unknown_type" );
        }
    }
}



## check

1. Метод check возвращает возвращает тип сущности в случае, если она была 
определена или пустой результат в противном случае.

### aргументы check

1. Метод check принимает следующие аргументы:
    1. ```char32 id``` - Идентификатор сущности;

### результат check

1. Метод define возвращает структуру состояний результата c указанием типа 
сущности.

### алгорим check

```
json check
(
    /* Идентификатор сущности */
    char32 id
)
{
    /* Выполняем поиск сущности по идентификатору */
    dataset = entity -> select({ "id":"id" });

    /* Проверка результата поиска ... */
    if( dataset != null )
    {
        /*
            Запись найдена, выполняем определение типа из кортежа
        */
        idType = dataset -> get( "type_id ");
        /* Проверка наличия типа */
        if idType == null )
        {
            /* Тип не указан, cущность была удалена */
            result = { "code":"entity_not_found" }
        }
        else
        {
            /* 
                Удалось определить идентификатор тип и необходимо
                получить его название
            */
            datasetRid = rid -> select({ "entity_id": idType });
            if( datastRid != null )
            {
                /* Возвращаем тип результата */
                result = 
                {
                    "code":"ok", 
                    "ridType":datasetRid -> get( "rid" ),
                    "idType":idType
                };
            }
            else
            {
                /* 
                    Имя типа сущности не найдено что является 
                    исключительной ситуацией 
                */
                result = { "code":"type_name_not_found" }
            }
        }
    }
    else
    {
        /* Сущность не найдена */
        result = { "code":"entity_not_found" }
    }
}
```


## rid2id

## id2rid



## delete

1. Метод del пытается удалить сущность по идетификатору.
2. При наличии сущности она будет удалена с подтверждением результата удаления.
3. При отсутсвии сущности возвращается инфомрация об отсутсвии сущности.
4. Метод не пытается проверить целостность ссылок на сущности, а потому может 
быть удалена любая из сущностей.

### вызов delete

``` 
bool del( string id, array string dum[] )
```

### аргументы del

1. Метод del принимает следующие аргументы:
    1. ```string id``` - Идентификатор сущности;
    2. ```array string dim[]``` - массив измерений.

### результат del

1 Метод del возаращет положительный результ, если cущность после попытки 
удаления, и отрицательный результат если сущность осталась.



