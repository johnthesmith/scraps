# SIAMA 

1. Separation of Initiative & Action Microservice Architeture - микросервисная 
архитектура на основе разделения инициативы и действия описывает подход к 
реализации [МСА](./glossary/МСА.md) приложения при котором старт [бизнес 
процесса](./glossary/Бизнеспроцесс.md) выделен в отдельный микросервис с 
минималистичным функционалом.

# Оглавление

1. [Определения](#Определения)
0. [Причины разделения инициативы и действия](#Причины-разделения-инициативы-и-действия)
0. [Обеспечение отказоустойчивости](#Обеспечение-отказоустойчивости)
0. [Распределение нагрузки](#Распределение-нагрузки)
0. [Балансировщик](#Балансировщик)
0. [Вторичные вызовы](#Вторичные-вызовы)
0. [Работа прецептора](#Работа-прецептора)
0. [Внешний мир](#Внешний-мир)
0. [Синхронные запросы](#Синхронные-запросы)
0. [Асинхронные](#Асинхронные-запросы)

# Определения

1. [Прецептор](./glossary/Прецептор.md) – сервис исполнитель логики приложения.
0. [Инцептор](./glossary/Инцептор.md) – сервис, обладающий инициативой, подает 
сигнал на исполнение Прецептору.

```mermaid
graph LR;
    inceptor[Инцептор]
    preceptor[Прецептор]

    inceptor --> |Синхронный запрос| preceptor;
    preceptor -.-> |Результат| inceptor;
```

> **Термины** 
> Прецептор и Инцептор введены для явного указания на конкретные 
> роли в SIAMA.


3. Взаимодействие между Инцептором и Прецептором представляется как функция 
результата от аргументов: ```R = f( A )```, Инцептор передает фиксированный 
перечень аргументов A Прецептору, который выполняет 
[реализацию](./glossary/Rig.md) и возвращает результат-состояние R.

4. Инцептор на основе состояния определяет момент следующего вызова.

> **Принципиальное ограничение**
> Инцептор не управляет Прецептором после передачи вызова.
> Он лишь инициирует выполнение, а дальнейший процесс полностью
> контролируется Прецептором без обратного вмешательства.




# Причины разделения инициативы и действия

1. Разделение инициативы и действия выполнено по следующим причинам:
    1. [Обеспечение отказоустойчивости](#обеспечение-отказоустойчивости)
    2. [Распределение нагрузки](#распределение-нагрузки)



# Обеспечение отказоустойчивости

1. Объединение функций инициации и исполнения создаёт риск остановки процесса  
   из-за потенциальных сбоев логики. Разделение позволяет Инцептору надёжно  
   запускать задачи, даже если Прецептор выходит из строя.



# Распределение нагрузки 

1. Прецепторы выполняют ресурсоёмкие задачи, Инцепторы запускают их в нужном  
   количестве, гарантируя непрерывное параллельное выполнение.



# Балансировщик

1. Для исключения необходимости информировать Инцепторы о множестве Прецепторов 
   и для обеспечения автоматической балансировки нагрузки, схема дополняется 
   компонентом Балансировщика. Выбор уровня балансировки (L3, L4, L7) в статье 
   не рассматривается.

```mermaid
flowchart LR
    balancer([ Балансировщик ])
    inceptor([Инцепторы])@{ shape: processes }
    preceptor([Прецепторы])@{ shape: processes }

    inceptor --> balancer --> preceptor
```


# Вторичные вызовы

1. В процессе исполнения действия Прецетор может осуществить повторный вызов
иных прецепторов, что позволяет многократно выполнять различную логику на 
единнообразных компоеннтах и разспределять нагрузку на различен Прецепторы
в рамках одного бзнеспроцесса.

```mermaid
flowchart LR
    balancer([ Балансировщик ])
    inceptor([Инцепторы])@{ shape: processes }
    preceptor([Прецепторы])@{ shape: processes }

    inceptor --> balancer --> |первичный вызов| preceptor --> |вторичные вызовы| balancer
```



# Работа прецептора

1. Для исполнения бизнеспроцессов Прцепторам необходимо взаимодействовать с:
    1. иными Прецепторами для передачи вызова внутри siaar.
    0. сервисами Провайдерами, которые могут быть хранилищами состояний 
    или сервисам вне SIAMA;
2. С учетом изложенного следует расширить схему следующим образом:

```mermaid
flowchart LR

    subgraph SIAMA
        balancer[ Балансирвщик ]
        inceptor([Инцепторы])@{ shape: processes }
        preceptor([Прецепторы])@{ shape: processes }
    end

    provider([Провайдеры])@{ shape: processes }

    inceptor --> balancer
    balancer --> |Первичный <br> вызов| preceptor
    preceptor --> |Вторичный вызов <br> SIAMA| balancer
    preceptor --> |Вызовы вне<br> SIAMA| provider
```


# Внешний мир

1. Приложение должно взаимодействовать с внешним миром.
2. Для балансировки запросов и преобразования входящих запросов в воспринимаемые 
Прецепторами аргументы необходим Вншений балансировщик.
3. Таким образом полная схема приложения с учетом копонентов внешнего мира может 
выглядеть следующим образом:

```mermaid
flowchart LR
    
    subgraph SIAMA
        inceptor([Инцепторы])@{ shape: processes }
        preceptor([Прецепторы])@{ shape: processes }
        balancer[Балансировщик]
    end

    provider(Провайдеры)@{ shape: processes }
    client(Клинеты)@{ shape: processes }

    preceptor --> provider
    inceptor --> balancer
    client --> balancer
    preceptor --> balancer
    balancer --> preceptor
```



# Синхронные запросы

1. Синхронные запросы поступают в приложение со стороны Клиента.
0. При обработке запросов Прецепторы могут многократно вызывать друг друга через Балансировщик.
0. В процессе работы Прецепторы могут изменять состояния и взаимодействовать с Провайдерами.
0. Результат обработки цепочки запросов возвращается Клиенту.



# Асинхронные запросы

1. Асинхронные запросы выполняются по инициативе Инцепторов путем направления 
синхронного запроса от Инцептора к Балансировщику.
0. При обработке запросов Прецепторы могут многократно вызывать друг друга 
через Балансировщик.
0. Прецепторы могут изменять состояния и взаимодействовать с Провайдерами.
0. Результат обработки цепочки запросов возвращается Инцептору.


